<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLOVA Speech API Test</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; }
        .container { max-width: 800px; margin: auto; }
        .section { margin-bottom: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        h2 { border-bottom: 2px solid #007BFF; padding-bottom: 5px; }
        input[type="file"], button { padding: 10px; margin-top: 10px; }
        textarea { width: 100%; height: 150px; margin-top: 10px; padding: 10px; border: 1px solid #ccc; }
        #audio_upload_result, #stream_result { white-space: pre-wrap; background-color: #f9f9f9; padding: 15px; border-radius: 5px; margin-top: 10px; }
        .status-message { font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>

<div class="container">
    <h1>CLOVA Speech API 테스트 페이지</h1>

    <div class="section">
        <h2>실시간 음성 스트리밍 (WebSocket)</h2>
        <p>마이크를 통해 음성을 입력하면 실시간으로 텍스트로 변환됩니다. '시작' 버튼을 누르면 인식이 시작됩니다.</p>
        <button id="startStreamBtn">음성 인식 시작</button>
        <button id="stopStreamBtn" disabled>음성 인식 중지</button>
        <div class="status-message" id="streamStatus">대기 중...</div>
        <textarea id="stream_result" placeholder="실시간 변환 결과가 여기에 표시됩니다."></textarea>
    </div>
    
    <div class="section">
        <h2>음성 파일 변환 (File Upload)</h2>
        <p>음성 파일을 선택한 후 '변환 요청' 버튼을 누르면 변환 결과가 반환됩니다.</p>
        <input type="file" id="audioUploadInput" accept="audio/*,video/*">
        <button id="uploadBtn">변환 요청</button>
        <div class="status-message" id="uploadStatus">대기 중...</div>
        <textarea id="audio_upload_result" placeholder="파일 변환 결과가 여기에 표시됩니다."></textarea>
    </div>
</div>

<script>
    // 오디오 스트리밍 관련 변수
    let ws = null;
    let recognitionInProgress = false;
    let audioContext;
    let mediaStreamSource;
    let scriptNode;

    // 스트리밍 시작 함수
    document.getElementById('startStreamBtn').addEventListener('click', async () => {
        if (recognitionInProgress) return;

        const statusMessage = document.getElementById('streamStatus');
        const resultTextarea = document.getElementById('stream_result');
        const startBtn = document.getElementById('startStreamBtn');
        const stopBtn = document.getElementById('stopStreamBtn');

        try {
            statusMessage.textContent = '마이크 접근 허용을 기다리는 중...';
            // 마이크 접근 요청
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

            statusMessage.textContent = '서버에 연결 중...';
            // WebSocket 연결
            ws = new WebSocket(`ws://${window.location.host}/ws/transcribe/stream`);
            
            ws.onopen = () => {
                statusMessage.textContent = '연결 성공! 음성 인식을 시작합니다...';
                recognitionInProgress = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;

                // AudioContext와 MediaStreamSource 생성
                audioContext = new AudioContext({ sampleRate: 16000 });
                mediaStreamSource = audioContext.createMediaStreamSource(stream);
                
                // ScriptProcessorNode를 이용해 오디오 데이터 처리
                scriptNode = audioContext.createScriptProcessor(4096, 1, 1);
                
                scriptNode.onaudioprocess = (audioProcessingEvent) => {
                    if (!recognitionInProgress) return;
                    const inputBuffer = audioProcessingEvent.inputBuffer;
                    const pcmData = new Int16Array(inputBuffer.getChannelData(0).length);
                    
                    // Float32 데이터를 Int16로 변환
                    const channelData = inputBuffer.getChannelData(0);
                    for (let i = 0; i < channelData.length; i++) {
                        pcmData[i] = Math.min(1, channelData[i]) * 0x7FFF;
                    }
                    
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(pcmData.buffer);
                    }
                };

                // 노드 연결
                mediaStreamSource.connect(scriptNode);
                scriptNode.connect(audioContext.destination);
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.text) {
                    if (data.is_final) {
                        resultTextarea.value += data.text + '\n';
                    } else {
                        // 최종 결과가 아닐 경우, 이전 줄을 덮어씁니다.
                        const lines = resultTextarea.value.split('\n');
                        lines[lines.length - 1] = data.text;
                        resultTextarea.value = lines.join('\n');
                    }
                } else if (data.error) {
                    statusMessage.textContent = `오류: ${data.error}`;
                    stopStreaming();
                }
            };

            ws.onclose = () => {
                statusMessage.textContent = '연결이 종료되었습니다.';
                stopStreaming();
            };

            ws.onerror = (error) => {
                statusMessage.textContent = '연결 오류 발생.';
                console.error('WebSocket Error:', error);
                stopStreaming();
            };

        } catch (error) {
            statusMessage.textContent = `오류 발생: 마이크 접근 실패 또는 서버 연결 오류.`;
            console.error('WebSocket Connection Error:', error);
            stopStreaming();
        }
    });

    // 스트리밍 중지 함수
    document.getElementById('stopStreamBtn').addEventListener('click', stopStreaming);

    function stopStreaming() {
        if (!recognitionInProgress) return;

        if (ws) {
            ws.close();
        }
        if (audioContext && audioContext.state !== 'closed') {
            audioContext.close();
        }
        recognitionInProgress = false;
        document.getElementById('streamStatus').textContent = '대기 중...';
        document.getElementById('startStreamBtn').disabled = false;
        document.getElementById('stopStreamBtn').disabled = true;
    }

    // 파일 업로드 관련 함수
    document.getElementById('uploadBtn').addEventListener('click', async () => {
        const fileInput = document.getElementById('audioUploadInput');
        const statusMessage = document.getElementById('uploadStatus');
        const resultTextarea = document.getElementById('audio_upload_result');
        const file = fileInput.files[0];

        if (!file) {
            alert('음성 파일을 선택해주세요.');
            return;
        }

        const formData = new FormData();
        formData.append('media', file);
        formData.append('language', 'ko-KR');
        formData.append('completion', 'async');

        statusMessage.textContent = '파일 업로드 및 변환 요청 중...';
        resultTextarea.value = '';

        try {
            const response = await fetch('/api/transcribe/upload', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || `HTTP Error! status: ${response.status}`);
            }

            const data = await response.json();
            const token = data.token;
            statusMessage.textContent = `요청 성공! 토큰: ${token}. 결과를 조회합니다...`;

            // 상태 조회 루프
            const checkStatus = setInterval(async () => {
                const statusResponse = await fetch(`/api/transcribe/status/${token}`);
                const statusData = await statusResponse.json();
                
                if (statusData.status === 'RUNNING') {
                    statusMessage.textContent = `작업 진행 중...`;
                } else if (statusData.status === 'COMPLETED') {
                    clearInterval(checkStatus);
                    statusMessage.textContent = `작업 완료!`;
                    resultTextarea.value = JSON.stringify(statusData, null, 2);
                } else if (statusData.status === 'FAILED') {
                    clearInterval(checkStatus);
                    statusMessage.textContent = `작업 실패!`;
                    resultTextarea.value = JSON.stringify(statusData, null, 2);
                }
            }, 2000); // 2초마다 상태 체크

        } catch (error) {
            statusMessage.textContent = `오류: ${error.message}`;
            console.error('File Upload Error:', error);
        }
    });
</script>

</body>
</html>